<#
.SYNOPSIS
    Export SQL file generated by SSMS into yuniql

.DESCRIPTION
    A script to parse SSMS generated SQL file and split them into several files based on
    its object type (stored procedure, table, index, etc). This script will create the 
    folder structure and add number for easier maintenance.

.PARAMETER Path
    A path to SQL generated file, f.e. D:\Temp\generated.sql. This parameter is required.

.PARAMETER Destination
    A path to yuniql version folder, f.e. D:\Temp\eprocure.db\v0.00. This script will 
    generate the folder structure for you. You can also use _draft folder as parameter
    value. This parameter is not required, by default, it will use current location when
    not specified. It also reuse existing files to continue numbering, f.e. when in 
    D:\Temp\eprocure.db\v0.00\tables has these files 01-WelcomeMessage1.sql, then it will
    continue number 02 as next numbering.

.PARAMETER Flatten
    Determine whether to store in single folder, no folder structure (based on type) will
    be created. Use this to create a patch or the new objects are only few.

.EXAMPLE
    Set-Location D:\Temp\eprocure.db\v0.00
    Export-GeneratedSql.ps1 -Path D:\Temp\generated.sql
    
    Description
    -----------
    Set current location to D:\Temp\eprocure.db\v0.00 as working directory and parse 
    D:\Temp\generated.sql into current folder.

    Export-GeneratedSql.ps1 -Path D:\Temp\generated.sql -Destination D:\Temp\eprocure.db\_draft

    Description
    -----------
    Parse file D:\Temp\generated.sql and store yuniql script into D:\Temp\eprocure.db\_draft.
    
#>
function Export-GeneratedSql {
    [CmdletBinding()]
    param(
        [string]
        [Parameter(Mandatory=$true)]
        $Path,

        [string]
        $Destination = (Get-Location),

        [switch]
        $Flatten
    )

    Begin {
        $MetaPattern = [regex]::new('\/\*+ Object:\s*(?<type>\w+)\s+(\[?(?<schema>\w+)\]?\.)?\[?(?<name>\w+)\]?', [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
        $SqlFile = Get-Item $Path
        $TargetPath = Get-Item $Destination
        $Content = Get-Content $SqlFile
        Write-Verbose "Exporting file '$($SqlFile.FullName)' into $($TargetPath.FullName)"
        $Script:TargetFolders = @{}
        $Script:LastNumber = @{}
    }

    Process {
        $FileBuilder = [System.Text.StringBuilder]::new()
        $LastObject = @{}
        foreach ($Line in $Content) {
            $Match = $MetaPattern.Match($Line)
            if ($Match.Success) {
                if ($FileBuilder.Length -gt 0 -and -not([string]::IsNullOrEmpty($LastObject['Type']))) {
                    Write-SqlFile -TargetPath $TargetPath -Name $LastObject['Name'] -Type $LastObject['Type'] -Content ($FileBuilder.ToString()) -Flatten:$Flatten
                }
                $FileBuilder.Clear() | Out-Null
                $LastObject['Type'] = $Match.Groups['type'].Value -replace 'UserDefined'
                $LastObject['Name'] = $Match.Groups['name'].Value
                $LastObject['Schema'] = $Match.Groups['schema'].Value
                Write-Verbose "Got metadata: $($LastObject['Type']) $($LastObject['Name'])"
                if (-not([string]::IsNullOrEmpty($Line))) {
                    $FileBuilder.AppendLine($Line) | Out-Null
                } else {
                    $FileBuilder.Append($Line) | Out-Null
                }
            }
            else {
                if (-not([string]::IsNullOrEmpty($Line))) {
                    $FileBuilder.AppendLine($Line) | Out-Null
                } else {
                    $FileBuilder.Append($Line) | Out-Null
                }
            }
        }
        if ($FileBuilder.Length -gt 0) {
            Write-SqlFile -TargetPath $TargetPath -Name $LastObject['Name'] -Type $LastObject['Type'] -Content ($FileBuilder.ToString()) -Flatten:$Flatten
        }
    }
}

$TargetFolders = @{}
$LastNumber = @{}
function Write-SqlFile {
    [CmdletBinding()]
    param(
        [string]$TargetPath,
        [string]$Name,
        [string]$Type,
        [string]$Content,
        [switch]$Flatten
    )

    Process {
        $Folder = if ($Flatten) {
            $TargetPath
        } else {
            if (-not($TargetFolders.ContainsKey($Type))) {
                $Folder = Get-TargetFolder -Path $TargetPath -Type $Type
                $TargetFolders[$Type] = $Folder
            }
            $TargetFolders[$Type]
        }
        $Seq = Get-NewNumber -Path $Folder -Type $Type
        if ($Flatten) {
            $Name = "$($Name).$($Type)"
        }
        $Filename = [string]::Format('{0:000}-{1}.sql', $Seq, $Name)
        $FilePath = Join-Path -Path $Folder -ChildPath $Filename
        Write-Verbose "Writing to file '$($FilePath)'"
        Set-Content -Path $FilePath -Value $Content -Force | Out-Null
    }
}

function Get-TargetFolder {
    [CmdletBinding()]
    param(
        [string]$Path,
        [string]$Type
    )

    Process {
        $Folder = (Get-ChildItem -Path $Path -Directory | ?{ $_ -like "\d+\-$($Type.ToLower())*" })
        if ($null -eq $Folder) {
            $Seq = Get-NewNumber -Path $Path -Type 'Structure'
            $Folder = Join-Path -Path $Path -ChildPath ([string]::Format('{0:00}-{1}', $Seq, $Type.ToLower()))
            Write-Verbose "Creating directory '$Folder'"
            New-Item -Path $Folder -ItemType Directory -Force | Out-Null
            return $Folder
        } else {
            return $Folder.FullName
        }
    }
}

function Get-NewNumber {
    [CmdletBinding()]
    param(
        [string]$Path,
        [string]$Type
    )

    Begin {
        $SeqPattern = '^(?<seq>\d+)\-(?<name>.+)'
    }

    Process {
        if ($LastNumber.ContainsKey($Type)) {
            $LastNumber[$Type] = $LastNumber[$Type] + 1
            return $LastNumber[$Type]
        }

        $Sequences = @(Get-ChildItem -Path $Path -Directory)
        $Sequences += @(Get-ChildItem -Path $Path -File -Filter *.sql)
        $MaxNumber = ($Sequences | ?{ $_.Name -match $SeqPattern } | %{ $_.Name -replace $SeqPattern, '$1' } | %{ [int]::Parse($_) } | measure -Maximum).Maximum
        if ($null -eq $MaxNumber) {
            Write-Verbose "Retrieving last number from '$Path', got nothing, using 1 as starting point"
            $MaxNumber = 1
        } else {
            Write-Verbose "Retrieving last number from '$Path', got '$MaxNumber', increasing by 1"
            $MaxNumber++
        }
        $LastNumber[$Type] = $MaxNumber
        return $LastNumber[$Type]
    }
}
